// Fonction pour sauvegarder un fichier ressource sur GitHub
async function saveResourceToGitHub(machineId, resource) {
    try {
        if (!githubCredentials.owner || !githubCredentials.repo || !githubCredentials.token) {
            throw new Error("Identifiants GitHub manquants");
        }

        // Créer un dossier resources/machineID si nécessaire
        const resourceFolder = `resources/${machineId}`;
        
        // Extraire le contenu base64 du dataURL (enlever le préfixe data:mime/type;base64,)
        let base64Content = resource.data;
        if (base64Content.includes('base64,')) {
            base64Content = base64Content.split('base64,')[1];
        }
        
        // Créer un nom de fichier unique pour éviter les conflits
        const safeFileName = resource.name.replace(/[^a-zA-Z0-9._-]/g, '_');
        const uniqueFileName = `${Date.now()}-${safeFileName}`;
        
        // Chemin complet du fichier
        const filePath = `${resourceFolder}/${uniqueFileName}`;
        
        // URL de l'API GitHub pour créer/mettre à jour un fichier
        const url = `https://api.github.com/repos/${githubCredentials.owner}/${githubCredentials.repo}/contents/${filePath}`;
        
        // Envoyer la requête à GitHub
        const response = await fetch(url, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${githubCredentials.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: `Ajout de la ressource ${uniqueFileName} pour la machine ${machineId}`,
                content: base64Content
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Erreur GitHub: ${response.status} - ${errorData.message}`);
        }
        
        const responseData = await response.json();
        
        // Retourner l'URL du fichier sur GitHub
        return {
            path: filePath,
            url: responseData.content.html_url,
            sha: responseData.content.sha,
            name: resource.name,
            type: resource.type,
            size: resource.size,
            uploadDate: resource.uploadDate || new Date().toLocaleString()
        };
    } catch (error) {
        console.error("Erreur lors de la sauvegarde du fichier ressource :", error);
        throw error;
    }
}

// Fonction pour supprimer un fichier ressource sur GitHub
async function deleteResourceFromGitHub(resourceInfo) {
    try {
        if (!githubCredentials.owner || !githubCredentials.repo || !githubCredentials.token || !resourceInfo.path || !resourceInfo.sha) {
            throw new Error("Informations manquantes pour supprimer le fichier");
        }
        
        // URL de l'API GitHub pour supprimer un fichier
        const url = `https://api.github.com/repos/${githubCredentials.owner}/${githubCredentials.repo}/contents/${resourceInfo.path}`;
        
        // Envoyer la requête à GitHub
        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'Authorization': `token ${githubCredentials.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: `Suppression de la ressource ${resourceInfo.name}`,
                sha: resourceInfo.sha
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Erreur GitHub: ${response.status} - ${errorData.message}`);
        }
        
        return true;
    } catch (error) {
        console.error("Erreur lors de la suppression du fichier ressource :", error);
        throw error;
    }
}

// Fonction pour télécharger un fichier depuis GitHub
async function downloadResourceFromGitHub(resourceInfo) {
    try {
        if (!githubCredentials.owner || !githubCredentials.repo || !resourceInfo.path) {
            throw new Error("Informations manquantes pour télécharger le fichier");
        }
        
        // URL de l'API GitHub pour obtenir le contenu d'un fichier
        const url = `https://api.github.com/repos/${githubCredentials.owner}/${githubCredentials.repo}/contents/${resourceInfo.path}`;
        
        // Envoyer la requête à GitHub
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `token ${githubCredentials.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Erreur GitHub: ${response.status} - ${errorData.message}`);
        }
        
        const data = await response.json();
        
        // Construire un dataURL à partir du contenu base64
        const dataUrl = `data:${resourceInfo.type || 'application/octet-stream'};base64,${data.content}`;
        
        return dataUrl;
    } catch (error) {
        console.error("Erreur lors du téléchargement du fichier ressource :", error);
        throw error;
    }
}

// Modification de la fonction uploadResource pour sauvegarder le fichier sur GitHub
async function uploadResource(machineId) {
    const fileInput = document.getElementById(`file_${machineId}`);
    const file = fileInput.files[0];
    
    if (!file) {
        alert("Veuillez sélectionner un fichier");
        return;
    }
    
    try {
        updateSyncStatus("Téléversement du fichier...");
        
        const reader = new FileReader();
        reader.onload = async function(e) {
            if (!resources[machineId]) {
                resources[machineId] = [];
            }
            
            // Créer un objet ressource local
            const resourceData = {
                name: file.name,
                type: file.type,
                size: file.size,
                data: e.target.result,
                uploadDate: new Date().toLocaleString()
            };
            
            try {
                // Option 1: Sauvegarder immédiatement sur GitHub
                if (githubCredentials.token) {
                    const githubResource = await saveResourceToGitHub(machineId, resourceData);
                    
                    // Stocker localement uniquement les métadonnées et le chemin GitHub
                    resources[machineId].push({
                        name: file.name,
                        type: file.type,
                        size: file.size,
                        path: githubResource.path,
                        sha: githubResource.sha,
                        githubUrl: githubResource.url,
                        uploadDate: new Date().toLocaleString(),
                        storedOnGitHub: true
                    });
                } else {
                    // Option 2: Stocker uniquement en local si pas de token GitHub
                    resources[machineId].push(resourceData);
                }
                
                saveData();
                updateResourceList(machineId);
                fileInput.value = "";
                updateSyncStatus("Synchronisé");
            } catch (error) {
                alert(`Erreur lors de l'envoi du fichier: ${error.message}`);
                updateSyncStatus("Erreur de téléversement");
            }
        };
        
        reader.readAsDataURL(file);
    } catch (error) {
        alert(`Erreur: ${error.message}`);
        updateSyncStatus("Erreur");
    }
}

// Mise à jour du rendu des ressources pour gérer les fichiers GitHub
function renderResourceList(machineId) {
    if (!resources[machineId] || resources[machineId].length === 0) {
        return "<div>Aucune ressource</div>";
    }
    
    return resources[machineId].map((resource, index) => {
        const isStoredOnGitHub = resource.storedOnGitHub;
        let downloadButton;
        
        if (isStoredOnGitHub) {
            // Pour les ressources sur GitHub, on affiche un bouton qui téléchargera le fichier à la demande
            downloadButton = `<button class="btn" style="padding: 3px 6px; font-size: 12px;" onclick="downloadAndOpenResource(${machineId}, ${index})">Télécharger</button>`;
        } else {
            // Pour les ressources locales, on utilise l'attribut download comme avant
            downloadButton = `<a href="${resource.data}" download="${resource.name}" class="btn" style="padding: 3px 6px; font-size: 12px;">Télécharger</a>`;
        }
        
        return `
            <div class="resource-item">
                <span>${resource.name} ${isStoredOnGitHub ? '(GitHub)' : '(Local)'}</span>
                <div>
                    ${downloadButton}
                    <button class="btn btn-danger" style="padding: 3px 6px; font-size: 12px;" onclick="deleteResource(${machineId}, ${index})">Supprimer</button>
                </div>
            </div>
        `;
    }).join("");
}

// Fonction pour télécharger et ouvrir une ressource stockée sur GitHub
async function downloadAndOpenResource(machineId, index) {
    try {
        updateSyncStatus("Téléchargement en cours...");
        
        const resource = resources[machineId][index];
        
        if (!resource.storedOnGitHub) {
            // Si la ressource est locale, l'ouvrir directement
            window.open(resource.data, '_blank');
            return;
        }
        
        // Télécharger depuis GitHub
        const dataUrl = await downloadResourceFromGitHub(resource);
        
        // Créer un élément temporaire pour le téléchargement
        const a = document.createElement("a");
        a.href = dataUrl;
        a.download = resource.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        updateSyncStatus("Synchronisé");
    } catch (error) {
        alert(`Erreur lors du téléchargement: ${error.message}`);
        updateSyncStatus("Erreur de téléchargement");
    }
}

// Mise à jour de la fonction deleteResource pour supprimer aussi sur GitHub
async function deleteResource(machineId, index) {
    if (confirm("Êtes-vous sûr de vouloir supprimer cette ressource ?")) {
        try {
            const resource = resources[machineId][index];
            
            // Si la ressource est stockée sur GitHub, la supprimer aussi de GitHub
            if (resource.storedOnGitHub && githubCredentials.token) {
                updateSyncStatus("Suppression du fichier sur GitHub...");
                await deleteResourceFromGitHub(resource);
            }
            
            // Supprimer la référence locale
            resources[machineId].splice(index, 1);
            saveData();
            updateResourceList(machineId);
            updateSyncStatus("Synchronisé");
        } catch (error) {
            alert(`Erreur lors de la suppression: ${error.message}`);
            updateSyncStatus("Erreur de suppression");
        }
    }
}

// Mise à jour de la fonction saveToGitHub pour migrer les ressources locales vers GitHub
async function saveToGitHub() {
    try {
        updateSyncStatus("Sauvegarde vers GitHub...");
        
        if (!githubCredentials.owner || !githubCredentials.repo || !githubCredentials.token) {
            throw new Error("Identifiants GitHub manquants");
        }
        
        // 1. Migrer les ressources locales vers GitHub si nécessaire
        for (const machineId in resources) {
            for (let i = 0; i < resources[machineId].length; i++) {
                const resource = resources[machineId][i];
                
                // Si la ressource n'est pas déjà sur GitHub et a des données
                if (!resource.storedOnGitHub && resource.data) {
                    try {
                        // Sauvegarder sur GitHub
                        const githubResource = await saveResourceToGitHub(machineId, resource);
                        
                        // Mettre à jour la référence locale
                        resources[machineId][i] = {
                            name: resource.name,
                            type: resource.type,
                            size: resource.size,
                            path: githubResource.path,
                            sha: githubResource.sha,
                            githubUrl: githubResource.url,
                            uploadDate: resource.uploadDate || new Date().toLocaleString(),
                            storedOnGitHub: true
                        };
                    } catch (error) {
                        console.error(`Erreur lors de la migration de la ressource ${resource.name}:`, error);
                    }
                }
            }
        }
        
        // 2. Sauvegarder les données principales
        const url = `https://api.github.com/repos/${githubCredentials.owner}/${githubCredentials.repo}/contents/${githubCredentials.filename}`;
        
        // Préparer les données à sauvegarder (sans inclure les fichiers binaires)
        const dataToSave = {
            machines,
            rooms,
            history,
            resources // Maintenant contient uniquement les métadonnées et les chemins
        };
        
        // Convertir en JSON et encoder en Base64
        const content = btoa(JSON.stringify(dataToSave, null, 2));
        
        // Récupérer le SHA du fichier s'il existe
        const sha = localStorage.getItem('githubFileSha');
        
        // Préparer le payload pour GitHub API
        const payload = {
            message: "Mise à jour des données GMAO",
            content: content
        };
        
        // Si le fichier existe déjà, ajouter son SHA pour le mettre à jour
        if (sha) {
            payload.sha = sha;
        }
        
        // Envoyer la requête à GitHub
        const response = await fetch(url, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${githubCredentials.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Erreur GitHub: ${response.status} - ${errorData.message}`);
        }
        
        const responseData = await response.json();
        
        // Mettre à jour le SHA
        localStorage.setItem('githubFileSha', responseData.content.sha);
        
        updateSyncStatus("Synchronisé");
        return true;
    } catch (error) {
        console.error("Erreur lors de la sauvegarde vers GitHub :", error);
        updateSyncStatus("Erreur de sauvegarde: " + error.message);
        return false;
    }
}

// Mise à jour de la fonction loadFromGitHub pour gérer les ressources
async function loadFromGitHub() {
    try {
        updateSyncStatus("Chargement depuis GitHub...");
        
        if (!githubCredentials.owner || !githubCredentials.repo || !githubCredentials.token) {
            throw new Error("Identifiants GitHub manquants");
        }
        
        const url = `https://api.github.com/repos/${githubCredentials.owner}/${githubCredentials.repo}/contents/${githubCredentials.filename}`;
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `token ${githubCredentials.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.status === 404) {
            // Le fichier n'existe pas encore, on va le créer lors du premier saveToGitHub
            updateSyncStatus("Fichier non trouvé, sera créé à la première sauvegarde");
            return;
        }
        
        if (!response.ok) {
            throw new Error(`Erreur GitHub: ${response.status}`);
        }
        
        const data = await response.json();
        const content = atob(data.content); // Décode le contenu en Base64
        const sha = data.sha; // On stocke le SHA pour les mises à jour ultérieures
        localStorage.setItem('githubFileSha', sha);
        
        const parsedData = JSON.parse(content);
        
        machines = parsedData.machines || [];
        rooms = parsedData.rooms || [];
        history = parsedData.history || {};
        resources = parsedData.resources || {};
        
        // S'assurer que toutes les ressources ont le flag storedOnGitHub
        for (const machineId in resources) {
            resources[machineId] = resources[machineId].map(resource => {
                if (resource.path && !resource.storedOnGitHub) {
                    resource.storedOnGitHub = true;
                }
                return resource;
            });
        }
        
        // Sauvegarder en local aussi
        localStorage.setItem('machines', JSON.stringify(machines));
        localStorage.setItem('rooms', JSON.stringify(rooms));
        localStorage.setItem('history', JSON.stringify(history));
        localStorage.setItem('resources', JSON.stringify(resources));
        
        updateRoomSelect();
        updateMachineList();
        updateSyncStatus("Synchronisé");
        
        return true;
    } catch (error) {
        console.error("Erreur lors du chargement depuis GitHub :", error);
        updateSyncStatus("Erreur de synchronisation: " + error.message);
        return false;
    }
}
